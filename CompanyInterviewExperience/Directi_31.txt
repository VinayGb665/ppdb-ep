There was coding round on CodeChef for 3 hours duration. You cannot use custom test cases within their IDE or edit your code after running.
Coding Problem 1
Amanada, a school kid, is learning English alphabets. Her teacher devised a small game to make the task fun. A grid of ‘m’ rows and ‘n’ columns is filled with English alphabets. She needs to search English words in this grid by moving one step at a time in any of the adjacent grid cells. A grid of alphabets and a set of English words are given. Amanda can start from anywhere in the grid and can move in any of the 8 adjacent grid cells, one step at a time. Each grid cell can only be used once.
Input: You are given a template in which you need to implement a function whose signature is given below.
Output :The function should return true, if you can find the word in the grid and false otherwise. Example Let’s consider the grid given below: a b c d e f g h i And set of words to be searched are: abc abedhi efgh
The output of the above example should be: abc: true abedhi: true efgh: false Constraints 1 ? m,n ? 100
Coding Problem 2 :You will get 2 points for solving this problem
You are given a rooted tree. The tree is not necessarily binary. The tree contains N nodes, labeled 1 to N. You are given the tree in the form of an array P[1..N] of size N. P[i] denotes label of the parent of node labeled i. For clarity, you may assume that the tree satisfies the following conditions.
Sample Input 2 5 5 3 0 1 1 1 3 ADD 1 10 ADD 2 20 ADD 3 30 ADD 4 40 ADDUP 5 50 VAL 3 VALTREE 3 VALTREE 1 7 4 5 0 1 2 2 2 1 2 ADD 6 76 ADDUP 1 49 ADD 4 48 ADDUP 2 59 VALTREE 1 VALTREE 5 VAL 5 VAL 5 VALTREE 2 VAL 2
Sample Output 80 130 250 291 0 0 107 59 Explanation In the first sample case, at the end of app the operations, the values at each of the nodes is as follows 1: 60 2: 20 3: 80 4: 40 5: 50 Also, the sum of the values of all the nodes in the subtree rooted at each of the nodes is as follows 1: 250 2: 20 3: 130 4: 40 5: 50
Coding Problem 3: You will receive 1 point of solving this problem
In a binary tree, diameter sum between two leaf nodes is defined as sum of all the nodes in the unique path when traveling from one leaf to the other. Assume that the tree is a complete binary tree and every leaf node is at the same depth from root of the tree. Find the value of maximum diameter sum in a binary tree. Note that the maximum diameter may be a single leaf node as well (since a single leaf node is also a valid diameter ­ the trivial path of length 0 from the leaf node to itself).
Input :First line of input is the number T, which denotes the number of test cases. Input for each case consists of 2 lines. The first line consists of the number of nodes N in the tree. The following line consists of the numbers A[1..n] which denote the value of each node in the tree. The first element in the input is the root element of the tree. Considering index of root element is 1 in the following problem, left child of i’th element in the input is the (2*i)th element and right child of ith element is (2*i+1)th element.
Output :Output consist of T lines denoting the value of maximum diameter sum in binary tree for each test case. Solution Templates In the solution templates provided, complete the function whose signature is C / C++ int maxDiameterSum(int nodes, int tree[511]) Java static int maxDiameterSum(int nodes, int[] tree) The first argument to maxDiameterSum is the number of nodes in the tree. The second argument is tree, presented in an array format as described in the Input Section above. maxDiameterSum should return the value of the maximum diameter sum in the binary tree. Note: You are allowed to edit the code as you please. Add / delete headers. Add / delete methods. And so on.. So long as your final code solves the problem with Input and Output as described above.
You may submit your own code, without using the template at all. Constraints T ? 100 N ? 511 Range of value of nodes is between ­100000 and 100000 N is of the form 2 k ­1, where k is the height of the tree. Sample Input 1 7 2 4 5 8 ­4 3 ­6

