Given N(very large), task if to print the largest palindromic number obtained by permuting the digits of N. If it is not possible to make a palindromic number, then print an appropriate message. 
Examples :
Naive Approach :  The naive approach will be to try all the permutations possible, and print the largest of such combinations which is a palindrome. 
Efficient Approach : An efficient approach will be to use Greedy algorithm. Since the number is large, store the number in a string. Store the count of occurrences of every digit in the given number in a map.  Check if it is possible to form a palindrome or not. If the digits of the given number can be rearranged to form a palindrome, then apply the greedy approach to obtain the number. Check for the occurrence of every digit (9 to 0), and place every available digit at front and back. Initially, the front pointer will be at index 0, as the largest digit will be placed at first to make the number a large one. With every step, move the front pointer 1 position ahead. If the digit occurs an odd number of times, then place one digit in the middle and rest of the even number of digits at front and back. Keep repeating the process (map[digit]/2) number of times for a single digit. After placing a particular digit which occurs an even number of times at the front and back, move the front pointer one step ahead. The placing is done till map[digit] is 0. The char array will have the largest palindromic number possible after completion of the placing of digits greedily.  
In the worst case, the time complexity will be O(10 * (length of string/2)), in case the number consists of a same digit at every position.  
Below is the implementation of the above idea :
Run on IDE
Time Complexity : O(n), where n is the length of string.
