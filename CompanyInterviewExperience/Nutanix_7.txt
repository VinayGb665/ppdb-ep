Nutanix recently came to our college for recruiting interns. Around 130 people gave the coding round, and 12 were selected for interviews. Test was 1.5 hours long, with 2 questions.

Coding Round:
Q1: https://www.geeksforgeeks.org/minimum-positive-points-to-reach-destination/
I personally found the question tough. I started with the idea of representing dp[i][j] as the min number of points to reach till index [i][j] from [0][0]. However if you think deep you would get to know why‚Äôs it wrong, or in other words doesn‚Äôt produce the most optimal answer. 3 test cases passed.
Q2: Given a list of points with x and y coordinates, you have to calculate how many points are not dominated with any other point. A point ‚Äòp‚Äô is said to dominate another point ‚Äòq‚Äô, if p(x)>q(x) AND p(y)>q(y).
It didn‚Äôt take me much time to solve this problem. All test cases passed.

Round 1 interview: 
There were 3 people taking interview in parallel in three different cubicles. All of them asked the same questions to students giving the interview at the same time. Basically three people went, then all three came out, and next three went, and so on repeated two more time. So same set of questions to students having interview at the same time in parallel, and they would change questions for the next set of students.
Before telling questions asked to me, i would write down questions asked to others:
1. Given a linked list and pointer to a given node, how to delete this node. Note that pointer to no other node is given, not even the head. Just this given node. : https://www.geeksforgeeks.org/in-a-linked-list-given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/
2. Given a directed graph, find the mother vertex : https://www.geeksforgeeks.org/find-a-mother-vertex-in-a-graph/
3. Given an array of size n, find out the numbers which have duplicates. Numbers lie in the range 0 to n-1, and more than one number can have duplicates.: https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/
Some more easy questions i don‚Äôt remember. Anyways, the following questions were asked to me:
1. Given a BST with two nodes swapped, find the two nodes, and swap them back (Note that you have to swap the nodes, not just the value within them).
He asked me to code the solution, which i did. He was satisfied with the solution.
2. Given an undirected graph, and each vertex having some value associated with it, find the number of connected components with total value (meaning the sum of value of all the nodes within that connected component) as prime.
3. This was the trickiest questions. He asked me to implement Sieve. As soon as i started, he asked me what i was doing. I told him i made an array of size 10^6. He then asked ‚Äúof what type‚Äù. I said int. He asked if it was necessary? I said no, and made it bool. He said ‚ÄúCan you do better‚Äù. At first i didn‚Äôt get the question. Then he gave me a hint saying what does bool represent? I said yes or no. Then he asked how many bits do i need for that to represent, i said 1 bit. Like 0 for no and 1 for yes. So he said to use 1 bit. I didn‚Äôt have any idea of any data structure which can have size of given number of bits (although there exists one, i got to know later). So I said if i can make an integer of size 10^6 bits, then i could do. But it‚Äôs not possible to construct such integer. I even said that if i have such a int, then i can set and unset bits to do the required thing. He then made a struct and passed a pointer to an array and a value ‚Äúz‚Äù. He asked me the size of the array, after little discussion some slight mistakes, i said 10^6/(4*8); He said right. Then he asked me to set the bit ‚Äòz‚Äô. So i made two int x, y; x=z/32; y=z%32; and set the y‚Äôth bit of arr[x]. He asked me to write the code snippet to reset it too. I did it, he was happy.
Basically my first wound quite well. Before he started asking me questions, he even asked about me to explain any on of my project, like any favourite kind of. I explained him one related to orthogonal Latin Squares. He was quite happy to know what all i did.
Out of 12, 6 people got selected for the second round. 
Round 2 interview: 
3 people went first, next three immediately after them. As there wasn‚Äôt any possibility to discuss any question with those who went first, they gave exact same question to all.
It was a tech + HR round.
Only one tech question was asked, which was pretty simple.
Q: Given a BST with attributes Left*, Right*, Value, Locked, where locked and value are int, find out if a given node can be locked or not. A node can locked is none of it‚Äôs ancestor, or any node in the subtree with this given node as the root is locked.
I first told that i would do traversal till the given node (Given Node‚Äôs pointer is given, so i have the value, can do the traversal). I would check if there was any node which was locked while between reaching till that node. If yes, simply stop and print ‚ÄúNot Possible‚Äù. If no ancestor is locked, simply do some traversal of the subtree with that node as the root, and find if any node is locked. If yes, then print ‚ÄúNot Possible‚Äù. Else print ‚ÄúYes‚Äù. She asked the complexity, i said O(Log(N)) for reaching till the node, and O(N) for the traversal of subgraph. Basically Brute force type. She asked to Optimise it. I asked if i can introduce one more attribute in ‚Äústruct Node‚Äù definition. She allowed. Then i said i can do pre computation and find if any nodes‚Äô subtree with that node as the root has any node in it‚Äôs subtree locked. If yes, i would set this new attribute. Then when queries are fired, simply reach till that node in O(logN) time, check for the ancestors in the way. And if reached successfully, check this newly introduced attribute. She was happy with solution. Asked me to code it, i did. Then couple of general HR questions.
I really found them quite chilled and cool people. Everything went well üòâ üòÄ
Out of 6 people, two were finally selected. I enjoyed the whole process.
