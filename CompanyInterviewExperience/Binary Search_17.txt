Given an array of integers and a value k, find length of largest subarray having sum greater than k.
Examples:

A simple solution is to one by one consider each subarray and find its sum. If sum is greater than k, then compare length of this subarray with maximum length found so far. Time complexity of this solution is O(n2).
An efficient solution is to use prefix sum and binary search. The idea is to traverse the array and store prefix sum and corresponding array index in a vector of pairs. After finding prefix sum, sort the vector in increasing order of prefix sum, and for same value of prefix sum, sort according to index. Create another array minInd[], in which minInd[i] stores the minimum index value in range [0..i] in sorted prefix sum vector. After this, start traversing array arr[] and store sum of subarray arr[0..i] in sum. If sum is greater than k, then largest subarray having sum greater than k is arr[0..i] having length i + 1. If sum is less than or equal to k, then a value greater than or equal to k + 1 â€“ sum has to be added to sum to make it at least k+1. Let this value be x. To add x to sum, -x can be subtracted from it because sum-(-x) = sum + x. So a prefix array arr[0..j] (j<i), is needed to be found having sum at most -x (at most -x because k+1-sum is least value, now its negative is taken so it will be maximum value allowed). The resultant subarray arr[j+1..i] should be as large as possible. For this the value of j should be as minimum as possible. Thus the problem reduces to finding a prefix sum having value at most -x and its ending index should be minimum. To find the prefix sum, binary search can be performed on prefix sum vector. Let the index ind denotes that in prefix sum vector all prefix sum values upto index ind are less than or equal to -x. The minimum index value in range[0..ind] is minInd[ind]. If minInd[ind] is greater than i, then no subarray exists having sum -x in range[0..i-1]. Else arr[minInd[ind]+1..i] has sum greater than k. Compare its length with maximum length found so far. 
Below is the implementation of above approach:
Run on IDE
Time Complexity:  O(nlogn)
Auxiliary Space:  O(n)
