Given an unsorted array of length n and an integer k, find the minimum swaps to get the position of k before using the binary search. Here we can swap any two numbers as many times as we want. If we cannot get the position by swapping elements, print “-1”.
Examples:
Approach:  Before discussing the approach, we have to assume that here we are not supposed to swap the pairs. We just need to count the minimum number of swaps so that if we provide the newly created array to the binary search, we can get the position of k. In order to do so, we need to pass the given array to binary search and focus on the following things:-
Now following are the test cases that will occur during implementing the binary search:-
Case 1: If arr[mid] is greater than k, but position of k is greater than mid. Binary search would take us to (arr[0] to arr[mid-1]). But actually our element is in between (arr[mid+1] to arr[last element]). So, in order to go in the right direction, we need something smaller than k so that we can swap it with arr[mid] and we can go between arr[mid+1] to arr[last_element]. So, here we require one swap i.e. need_minimum.
Case 2:  If arr[mid] is less than k but position of k is smaller than mid. Binary search would take us to (arr[mid+1] to arr[last_element]). But actually our element is in between (arr[0] to arr[mid-1]). So, in order to go in the right direction, we need something greater than k so that we can swap it with arr[mid] and we can go between arr[0] to arr[mid-1]. So, here we required one swap i.e. need_maximum.
Case 3:
If arr[mid] is greater than k and position of k is lesser than mid. Now, in this case binary search would work fine. But wait, here is the important thing on which we have to work on. As we know in this case binary search will work fine, arr[mid] is at right position so this will not be used in any swap so here we have to decrease the one of it’s greater available element i.e. from num_max. Same goes with the case when arr[mid] is lesser than k and position of k is greater than mid. Here, we have to decrease one of it’s smaller available element i.e. from num_min.
Case 4: If arr[mid] == k Or pos == mid then we can easily come out from the binary search.
So, till now we have calculated the need_minimum i.e. number of minimum elements required for swapping, need_maximum i.e. number of maximum elements required for swapping, num_max i.e. total number of greater elements from k that are still available for swapping and num_min i.e. total number of minimum elements from k that are available for swapping.
Now here we have to consider two cases:
 Case 1: If need_minimum is greater than need_maximum. In this case, we have to swap all these needed maximum elements with the smaller of k. So we have to use the smaller elements from num_min. Now all the need_maximum swaps are done. Here the main thing is that when we swapped all these needed maximum elements with smaller elements, these smaller elements got their right positions. So, indirectly we have done some of the needed smaller elements swaps and that will be calculated as need_minimum – need_maximum and also available num_min will be num_min – need_maximum. Now, we have to calculate the remaining need_minimum swaps. We can calculate these swaps, if we have enough num_min i.e. num_min > need_minimum. For this case, swaps will be need_maximum + need_minimum otherwise it will be -1. The same concept goes with the case when we have need_minimum is smaller than need_maximum.
Below is the basic implementation of the above approach:-
Run on IDE
Output:
